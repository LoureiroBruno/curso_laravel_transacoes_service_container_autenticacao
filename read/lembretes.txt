================================================================================================================================================================================
mod 01

# Aprendemos a usar transações usando Laravel
# Vimos que há mais de uma sintaxe para trabalhar com transações

-----------------------------------------------------------------------------------------------------------------------------------


## bulk insert, para inserirmos vários dados de uma vez só em uma única query (consulta). 
## par resolver problemas de inconsistência é através de transações $pdo->beginTrasaction() e $pdo->commit(), é utilizando as facades DB, DB::transaction()
Essa função espera por parâmetro uma closure, função anônima e tudo que inserimos nela vai ocorrer dentro de uma transação, isto é, se fizermos um insert, um delete, um update, 
tudo isso vai estar dentro de uma única transação. 

public function store(SeriesFormRequest $request)
{
    DB::transaction(function () {

    });
}

## facade de DB usamos a função transaction() e ela possui algumas particularidades. 
## A primeira, é que ela recebe, além dessa closure, um segundo parâmetro, quando trabalhamos com transações pode ocorrer deadlock, isto é, se uma transação depende de duas tabelas e 
outra transação depende de outras duas tabelas, só que uma delas é igual. 
Por exemplo, a primeira transação depende da tabela de episódios, a segunda transação usa a de episódios mas depende da de temporadas que a primeira transação ainda está dependendo. 
Basicamente, é como se você perguntasse para a sua mãe, se você pode sair e ela responde para você verificar com o seu pai, e ao perguntar para o pai, ele informa para você verificar com a mãe. 
Isso é um deadlock e quando trabalhamos com transações, isso pode acontecer.
Então podemos informar para o Laravel tentar executar novamente essa transação em caso de deadlock, por exemplo, se quisermos tentar cinco vezes se houver deadlock, basta passarmos o 
parâmetro cinco Episode::insert($episodes); }, attempts:5);.

## A segunda, Não precisamos iniciar a variável serie em um estado inválido, passar por referência, &$serie, etc.
pós o Episode::insert($episodes); vamos digitar return $serie;
Agora o que a função transaction() vai fazer é pegar o retorno de toda a função
pegar o retorno da série incluindo $serie = antes de DB::transaction(function () use ($request), isto é, temos as séries em mãos e podemos acessar o nome dela.

$serie = DB::transaction(function () use ($request)

public function store(SeriesFormRequestCreate $request)
{
    /** obtém o return $series */
    $serie = DB::transaction(function () use ($request){
        
        $serie = Series::create($request->all());

        $seasons = [];
        for ($s=1; $s <= $request->seasonQty; $s++) {
            $seasons[] = [
                'series_id' => $serie->id,
                'number' => $s,
                'created_at' => $serie->created_at,
                'updated_at' => $serie->updated_at
            ];
        }

        /** bulk insert */
        Season::insert($seasons);

        $episodes = [];
        foreach ($serie->seasons as $season) {
            for ($e=1; $e <= $request->episodesPerSeason; $e++) {
                $episodes[] = [
                    'season_id' => $season->id,
                    'number' => $s,
                ];
            }
        }

            /** bulk insert */
        Episode::insert($episodes);

        return $serie;
    });

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}

## só que em caso de erro precisaríamos após o public function store(SeriesFormRequest $request) inserir um try{ e fechar as chaves só depois de return $serie;}); 
e tentar retornar essa resposta, só que em caso de erro, no cenário de um catch, se pegarmos uma exceção qualquer queremos garantir que seja exibido um erro.
Isso é um cenário comum, só que no nosso caso, com esse código vamos ter um nível de indentação, depois outro nível de indentação, assim, o código deixa de ser tão interessante. 
Se você fez o treinamento de object calisthenics já sabe que é interessante diminuirmos o número de indentações. 
public function store(SeriesFormRequestCreate $request)
{
    try {
        /** obtém o return $series */
        $serie = DB::transaction(function () use ($request){
        
            $serie = Series::create($request->all());
    
            $seasons = [];
            for ($s=1; $s <= $request->seasonQty; $s++) {
                $seasons[] = [
                    'series_id' => $serie->id,
                    'number' => $s,
                    'created_at' => $serie->created_at,
                    'updated_at' => $serie->updated_at
                ];
            }
    
            /** bulk insert */
            Season::insert($seasons);
    
            $episodes = [];
            foreach ($serie->seasons as $season) {
                for ($e=1; $e <= $request->episodesPerSeason; $e++) {
                    $episodes[] = [
                        'season_id' => $season->id,
                        'number' => $s,
                    ];
                }
            }
    
                /** bulk insert */
            Episode::insert($episodes);

            return $serie;
        });

        return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");

    } catch (\Throwable $th) {
        // exceção
    }
}

## usar uma sintaxe alternativa
ao invés de utilizar o transaction() usarmos o DB::beginTransaction();, assim, podemos remover a função anônima $serie = DB::transaction(function () use ($requestt) e a 
closure return $serie; e todo o código passa a estar no mesmo escopo que estava antes.
Apenas inserimos a linha DB::beginTransaction(); e no final DB::commit();. E agora, caso queiramos tratar aquele erro, podemos fazer o try catch e no catch adicionar o rollback. 
Igual fazemos com o PDO, então os métodos que conseguimos acessar no PDO, conseguimos acessar em DB.

public function store(SeriesFormRequestCreate $request)
{
    /** inicia a transação */
    DB::beginTransaction();
    $serie = Series::create($request->all());

    $seasons = [];
    for ($s=1; $s <= $request->seasonQty; $s++) {
        $seasons[] = [
            'series_id' => $serie->id,
            'number' => $s,
            'created_at' => $serie->created_at,
            'updated_at' => $serie->updated_at
        ];
    }

    /** bulk insert */
    Season::insert($seasons);

    $episodes = [];
    foreach ($serie->seasons as $season) {
        for ($e=1; $e <= $request->episodesPerSeason; $e++) {
            $episodes[] = [
                'season_id' => $season->id,
                'number' => $s,
            ];
        }
    }

    /** bulk insert */
    Episode::insert($episodes);
    /** finaliza a transação com sucesso */
    DB::commit();
    
    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");

    DB::rollBack();
}
**  DB::beginTransaction()irá apenas iniciar uma transação, enquanto para DB::transaction()você deve passar uma função Closure que será executada dentro de uma

** anotação
$serie = DB::transaction(function () use ($request){
    
    $serie = Series::create($request->all());

    $seasons = [];
    for ($s=1; $s <= $request->seasonQty; $s++) {
        $seasons[] = [
            'series_id' => $serie->id,
            'number' => $s,
            'created_at' => $serie->created_at,
            'updated_at' => $serie->updated_at
        ];
    }

    /** bulk insert */
    Season::insert($seasons);

    $episodes = [];
    foreach ($serie->seasons as $season) {
        for ($e=1; $e <= $request->episodesPerSeason; $e++) {
            $episodes[] = [
                'season_id' => $season->id,
                'number' => $s,
            ];
        }
    }

        /** bulk insert */
    Episode::insert($episodes);

    return $serie;
});

return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");

** anotação try

public function store(SeriesFormRequestCreate $request)
{
    /** inicia a transação */
    DB::beginTransaction();
    try {
        $serie = Series::create($request->all());

        $seasons = [];
        for ($s=1; $s <= $request->seasonQty; $s++) {
            $seasons[] = [
                'series_id' => $serie->id,
                'number' => $s,
                'created_at' => $serie->created_at,
                'updated_at' => $serie->updated_at
            ];
        }

        /** bulk insert */
        Season::insert($seasons);

        $episodes = [];
        foreach ($serie->seasons as $season) {
            for ($e=1; $e <= $request->episodesPerSeason; $e++) {
                $episodes[] = [
                    'season_id' => $season->id,
                    'number' => $s,
                ];
            }
        }

        /** bulk insert */
        Episode::insert($episodes);
        /** finaliza a transação com sucesso */
        DB::commit();
        return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");

    } catch (\RuntimeException $serie) {
        DB::rollBack();
        return to_route('series.index')->with("Danger", "Erro ao cadastar a série: '{$serie->nome}' com falha transação");
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 02

# 

-----------------------------------------------------------------------------------------------------------------------------------

## agora é separar uma classe específica para lidar com o banco de dados, Na pasta app ao invés de inserir dentro da pasta "Http", criar uma nova classe dentro da pasta Repositories
com namespace que vamos nomear de SeriesRepository.
Isso significa que vai ser uma classe que vai lidar com os detalhes de banco de dados, então, toda responsabilidade de tratar detalhes do banco de dados pode ser inserido nessa classe.

<?php

namespace App\Repositories;

class SeriesRepository
{

}

criando uma classe nova que vai estar no namespace novo que criamos chamado "Repositories", logo, essa classe é uma classe de repositório.
significa que vai ser uma classe que vai lidar com os detalhes de banco de dados, então, toda responsabilidade de tratar detalhes do banco de dados pode ser inserido nessa classe.
Como estamos usando o Eloquente não vamos precisar receber pelo construtor uma conexão com o PDO, por exemplo, é possível usar apenas o Eloquente. 
Parte do código para extrair em SeriesController.php
E no arquivo SeriesRepository.php vamos chamar esse método de add e receber o SeriesFormRequest por parâmetro, depois pensamos em como melhorar isso.

class SeriesRepository
{
    public function add(SeriesFormRequestCreate $request): Series
    {
        return DB::transaction(function () use ($request) {
       
            $serie = Series::create($request->all());

            $seasons = [];
            for ($s=1; $s <= $request->seasonQty; $s++) {
                $seasons[] = [
                    'series_id' => $serie->id,
                    'number' => $s,
                    'created_at' => $serie->created_at,
                    'updated_at' => $serie->updated_at
                ];
            }

            /** bulk insert */
            Season::insert($seasons);

            $episodes = [];
            foreach ($serie->seasons as $season) {
                for ($e=1; $e <= $request->episodesPerSeason; $e++) {
                    $episodes[] = [
                        'season_id' => $season->id,
                        'number' => $s,
                    ];
                }
            }

            /** bulk insert */
            Episode::insert($episodes);

            return $serie;
        });

    }
}

diferente da ultima alteração do controler SeriesController no metodo Create

public function store(SeriesFormRequestCreate $request)
{
    /** inicia a transação */
    DB::beginTransaction();
    try {
        $serie = Series::create($request->all());

        $seasons = [];
        for ($s=1; $s <= $request->seasonQty; $s++) {
            $seasons[] = [
                'series_id' => $serie->id,
                'number' => $s,
                'created_at' => $serie->created_at,
                'updated_at' => $serie->updated_at
            ];
        }

        /** bulk insert */
        Season::insert($seasons);

        $episodes = [];
        foreach ($serie->seasons as $season) {
            for ($e=1; $e <= $request->episodesPerSeason; $e++) {
                $episodes[] = [
                    'season_id' => $season->id,
                    'number' => $s,
                ];
            }
        }

        /** bulk insert */
        Episode::insert($episodes);
        /** finaliza a transação com sucesso */
        DB::commit();
        return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");

    } catch (\RuntimeException $serie) {
        DB::rollBack();
        return to_route('series.index')->with("Danger", "Erro ao cadastar a série: '{$serie->nome}' com falha transação");
    }
}


## agora Se estamos adicionando essa série no banco de dados com todas as suas temporadas, episódios e retornando ela dentro da nova Calsse SeriesRepository,
no controller em SeriesController.php podemos remover a parte do código que colamos no repositório e usar somente ele para isso. Nós poderíamos fazer um 
new SeriesRepository() mas não vamos fazer dessa forma, vamos utilizar a injeção de dependência, isso significa que vamos solicitar ao Laravel para nos dar esse objeto já criado.

refatorado o metodo store do SeriesController

public function store(SeriesFormRequestCreate $request, SeriesRepository $repository)
{
    $serie = $repository->add($request);

    return to_route('series.index')->with("success", "Cadastrado a série: '{$serie->nome}' com sucesso!");
}

## Se utilizarmos esse repositório em vários métodos, podemos receber no construtor: public function __construtor(){}
public function __construct(private SeriesRepository $repository)
{
    $this->repository = $repository;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 03

# 

-----------------------------------------------------------------------------------------------------------------------------------

## 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 04

# 

-----------------------------------------------------------------------------------------------------------------------------------

## 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
================================================================================================================================================================================
mod 05

# 

-----------------------------------------------------------------------------------------------------------------------------------

## 

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

================================================================================================================================================================================
